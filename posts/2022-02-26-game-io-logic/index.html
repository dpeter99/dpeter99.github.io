<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Game engine logic systems | dpeter99's blog</title><meta name=keywords content><meta name=description content="Small exploration of game event systems for a University project"><meta name=author content="dpeter99"><link rel=canonical href=https://dpeter99.github.io/posts/2022-02-26-game-io-logic/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://dpeter99.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dpeter99.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dpeter99.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dpeter99.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dpeter99.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dpeter99.github.io/posts/2022-02-26-game-io-logic/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://dpeter99.github.io/posts/2022-02-26-game-io-logic/"><meta property="og:site_name" content="dpeter99's blog
"><meta property="og:title" content="Game engine logic systems"><meta property="og:description" content="Small exploration of game event systems for a University project"><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-04T17:55:48+00:00"><meta property="article:modified_time" content="2022-03-04T17:56:28+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Game engine logic systems"><meta name=twitter:description content="Small exploration of game event systems for a University project"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dpeter99.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Game engine logic systems","item":"https://dpeter99.github.io/posts/2022-02-26-game-io-logic/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Game engine logic systems","name":"Game engine logic systems","description":"Small exploration of game event systems for a University project","keywords":[],"articleBody":"Almost all games need some way to connect actions in the game world with events they cause. The simplest example is pressing a button to open a door. These connections in some cases can be hardcoded, “every door needs a button to open” and this is perfectly fine when we know that this will be true for the whole game. But we can’t always know the scope this precisely, and designers like to experiment to find the best way to interact with the game world.\nThe problem These logical connections need to be editable by as many people as possible. A level designer might want to add a door that needs a key, or a cinematic designer might want to play a complex sequence when the player reaches a segment of the level. This means that these connections can’t be implemented in code for each case. As that would either require a programmer to step in and write each connection, which would make development slow and cause friction between departments. The other option would be that the designers would need to write the connection code, but this would mean that the designers need to be able to write code. This is rarely the case and would mean that many good designers would need to learn a new discipline.\nExisting solutions Presumably, all games that have a large world or complex level logic have some system to solve this. Sadly not many companies share these components, and finding talks about them in the GDC Vault is also hard. There are 2 examples that I could find. From these, we can try to take inspiration. These solutions are at least Source Available and thus we can see how they are implemented.\nSource Engine Source Engine is made by valve and is a highly battle-tested engine. It is one of the oldest engines but we can learn a lot from it as many of the ideas developed for it are now industry standard.\nSource has an Input/Output System, it is a highly robust system for designing world logic. For example, all of Portal’s puzzles are made using it. The main strength of it is that after making the basic components the designers can do everything else without much help from the programmers. This is achieved with full integration with the Hammer world editor, and many smaller logical building blocks.\nI/O system The Valve developers wiki gives a really good overview of how it works, but I will try to summarize it here as well.\nLet’s start with what is visible from the system to the user. Anything that can move or has any amount of data or logic is called an entity in Source. These are special as they can have more data on them. One of the most basic examples for an entity is a model, as these need the path of the model to draw, and the textures or shaders to use.\nA more interesting example of entities are the non-visible ones, like spawners or particle emitters. These are not visible in the game, only in the editor.\nAll of these entities have an Input-Output tab in the editor\nIn the Source engine, you can set up connections between entities by connecting one of the entities’ outputs to another entity’s input. These Outputs act as events and they are specific to the type of entity. For example a “trigger region entity” might have an output named OnTrigger, they also have Outputs inherited from their parent classes. Then these Outputs can be mapped to the Inputs on other entities. These Inputs are basically actions they can perform. For example, a fire particle entity might have StartFire and Extinguish.\nThese connections can be easily managed from the editor. The user can set up connections to define a delay to apply to the event, and also send optional parameters.\nThe interface has a Convenient dropdown to select the output and an object picker to select the targets.\nThe power of this system comes from the fact that there are many Logical entities. This allows the implementation of more complex logic.\nExamples Some examples of these integrations form Unity and Source:\ngame_text entity This is used for displaying text on the screen like a chapter title. game_score entity This entity can be used to add or subtract a point from a player. light_spot entity This is a basic spotlight that has Inputs to turn it on ( TurnOn ) and off ( TurnOff ) and also to set a patterns to use for flickering the light. logic_auto entity This is an entity that can fire Outputs automatically when the game starts up. For example, it has OnMapSpawnwhich is fired any time the map is loaded, there are also versions of this output for when the map is loaded from a save or as the start of a new game. logic_branch entity This entity holds a single bool value that can be toggled using its inputs (Toggle and ToggleTest) and it has outputs for when it is set to true and false (OnTrue, OnFalse) logic_compare entity This entity can compare two inputs and fire an Output based on the values received by it. logic_relay entity Using this entity it is possible to forward a single event to many other entities. npc_maker entity This entity is responsible for spawning NPCs, it has properties to specify the type, squad, and relations, they will have. There are inputs to stop and start spawning or spawn a single one. The internals Most of the code for this is found in the cbase.cpp file of the source code. After a bit of reading, we can see that it calls the g_EventQueue.AddEvent to actually send the event. This has a few parameters that, define the name of the Input to call, the name of the target as a string. It also takes in the rest of the things we can configure in the UI, the delay, the optional parameter.\nAfter this, the EventQueue puts this into a list sorted by the time the event needs to fire (Current time + delay). An interesting thing to note is that EventQueue does not fire the event in the same call. The events are actually acted upon at the top of the core game update loop. This is done in the ServiceEvents function. This approach makes sure that long chains of events can’t cause lag.\nUnity Unity has released an example project that shows how a more complex game might be put together in their engine. This project is a small adventure game with localized logic puzzles.\nThey made an event system that they talked about in the accompanying Unity Learn course. In their scripts they send commands rather than events, this is only a naming difference, they mean the same thing as events. This event system is a simple one that only has a fixed number of event types ( None, Activate, Deactivate, Open, Close, Spawn, Destroy, Start, Stop). These are only to differentiate between the events sent to the same game object.\nComponents Sending commands Sending commands can be done by any script inheriting from SendGameCommand. This has a Send() function that other scripts can use to send events. There are many, pre-made scripts, that inherit from SendGameCommand. For example, SendOnCollisionEnter, SendOnCollisionExit, SendOnCollisionStay These send a command (event) on the respective collision event. There is also a full set of these for trigger events. The target of the events is a script called: Game Command Receiver.\nIn the picture above, you can see these components in action. There is a simple box collider and when the player enters (layer filter set to player), it sends an Activate command to the GameObject Crystal.\nReceiving commands Any GameObject that needs to receive commands (events) needs the Game Command Receiver component. This acts as a hub for directing the event to the right Function inside the right component, this is done by having an internal list of which event to send to which component of the GameObject. These are registered by the component that wants to receive a given event. Every script that wants to process commands is inherited from GameCommandHandler Witch registers itself in its Awake method. It also gives fields for setting what event to listen to, setting a cooldown, and starting the timer.\nThere are many already made scripts that do inherit from GameCommandHandler. These can do a variety of things like:\nPlaySound that will play a sound when it gets a command SetGameObjectActive will activate and deactivate a set of target game objects. SimpleTranslator Is a script that can move an object from a start position to an end position with a lot of configurable options. This is for example used for the Big doors in the demo scene ( DoorHuge in scene Level1 ). In the above image, we can see the other half of the previous example. This is the target of the switch from before. It has the Command receiver script that was targeted in the switch. The inspector of the receiver shows a list of scripts that send events to this, so it is easier to navigate backwards in the connections. There is also a material switcher component that is set to listen to Activate events, it is also set so that it only fires once. When it fires, it will switch out the material, so the gem will glow with blue.\nWith the gizmos turned back on we can see that the system has a deep editor integration as it shows the connected components with arrows leading to and from event sources.\nThere is also a second GameObject targeted by the Switch, this is a counter. When it gets activated 3 times, it fires a second command that moves the door down.\nProblems The system doesn’t allow a single component to target multiple objects, this results in the duplication of scripts on the same GameObjects. A good example of this is the switch above, where it has to trigger the graphical change on the Gem and the Counter increment.\nThe fact that there is a limited number of event types is also a means that expressing more complex or abstract actions becomes hard, and some commands might end up with non-intuitive names.\nThe system also calls the target immediately, this means that if there is a chain in the calls (for example what a rellay component would do) the game might lag for a single frame while all the calls are made.\nThe requirements For designing a system that solves these logical connections, we need to decide what are the main requirements for it. At first, these requirements should be high level, to see what are the most important aspects.\nA world and gameplay logic system would need to be:\nEasy to use, eg. set up new connections Generic Fast 1. Easy to use The system needs to be easy to understand and use while developing the game. Any designer and non-programmer need to be able to add new connections to create the game world they envisioned. This means that the system needs good editor tooling and integration to allow for seamless workflows. We have seen this in both Unity and Source examples, they both have deep integration with the editor.\n2. Generic The system needs to be able to communicate with as many parts of the game and game engine, as possible. This means that the system should be able to interact with almost any part of the game. This for example includes the physics system, the cinematic choreography, inventory, and the quest system.\n3. Fast A system with this level of integration and usage needs to be fast. This can be achieved by using a similar system as what Valve is using. By only dispatching events at the top of the event loop, we can make sure, a longer event chain doesn’t make the game stop. But the Valve system isn’t perfect either. They do full name-based lookups which allows for wild card addressing and targeting multiple entities with the same name. But it can be costly.\nThe proposal so-far This exploration of game world logic systems was made for a University project. Our group is making a larger open-world game, and the need for a way to interconnect our systems came up. The plan is to use a single unified system for interacting with the world and completing quests.\nEntities From these examples, we have decided that in our system we will keep the idea of a single Component that marks the GameObject as something that can send and/or receive events. This component will mark the GO as an entity, and make sure it has a unique id (Most likely a UUID)\nThese Entities would register themselves to a list of all loaded entities that would allow for fast ID-based lookup of them when sending events. These might have a grouping based on the sub-scene to allow for fast and comprehensive unloading.\nThe question of time travel In our game, there is a chance that the target entity is not loaded, especially if the event is targeting multiple of the same type. The problem here is that if we just run the event when the entity gets loaded, then we might get undesired results. For example, when an explosion gets triggered, then that explosion will play out when that part of the map get’s loaded next. This might only happen in-game days later.\nTo avoid this, we might need to introduce states or some other way to differentiate between events that got delayed because of the target not being loaded. A simple solution would be to have a companion function for all events that care about this difference. This secondary function would only get called when the event was delayed. This still means that each component is responsible for handling the difference.\nThe problem of cloning There is also a second problem with only referring to entities with their UUID as this means that when a more complex entity is cloned, one that might have sub-entities, will have the same UUID as the one it was cloned from.\nAn example would be level designers using a prefab for a simple door. As they drag in the door, the UUID would stay the same and when firing a door open event, all the doors would open. Or when in-game a new enemy would spawn, it would also have conflicting internal IDs and no way to differentiate them from other enemies.\nThe solution to this problem is to make sure that when we clone any GameObject that is an entity, we regenerate the UUIDs\n","wordCount":"2448","inLanguage":"en","datePublished":"2022-03-04T17:55:48.039Z","dateModified":"2022-03-04T17:56:28.214Z","author":{"@type":"Person","name":"dpeter99"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://dpeter99.github.io/posts/2022-02-26-game-io-logic/"},"publisher":{"@type":"Organization","name":"dpeter99's blog\n","logo":{"@type":"ImageObject","url":"https://dpeter99.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dpeter99.github.io/ accesskey=h title="dpeter99's blog
 (Alt + H)">dpeter99's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Game engine logic systems</h1><div class=post-description>Small exploration of game event systems for a University project</div><div class=post-meta><span title='2022-03-04 17:55:48.039 +0000 UTC'>March 4, 2022</span>&nbsp;·&nbsp;dpeter99</div></header><div class=post-content><p>Almost all games need some way to connect actions in the game world with events they cause. The simplest example is pressing a button to open a door.
These connections in some cases can be hardcoded, &ldquo;<em>every door needs a button to open</em>&rdquo; and this is perfectly fine when we know that this will be true for the whole game.
But we can&rsquo;t always know the scope this precisely, and designers like to experiment to find the best way to interact with the game world.</p><h1 id=the-problem>The problem<a hidden class=anchor aria-hidden=true href=#the-problem>#</a></h1><p>These logical connections need to be editable by as many people as possible. A level designer might want to add a door that needs a key, or a cinematic designer might want to play a complex sequence when the player reaches a segment of the level.
This means that these connections can&rsquo;t be implemented in code for each case. As that would either require a programmer to step in and write each connection, which would make development slow and cause friction between departments.
The other option would be that the designers would need to write the connection code, but this would mean that the designers need to be able to write code. This is rarely the case and would mean that many good designers would need to learn a new discipline.</p><h1 id=existing-solutions>Existing solutions<a hidden class=anchor aria-hidden=true href=#existing-solutions>#</a></h1><p>Presumably, all games that have a large world or complex level logic have some system to solve this. Sadly not many companies share these components, and finding talks about them in the GDC Vault is also hard.
There are 2 examples that I could find. From these, we can try to take inspiration. These solutions are at least Source Available and thus we can see how they are implemented.</p><h2 id=source-engine>Source Engine<a hidden class=anchor aria-hidden=true href=#source-engine>#</a></h2><p>Source Engine is made by valve and is a highly battle-tested engine. It is one of the oldest engines but we can learn a lot from it as many of the ideas developed for it are now industry standard.</p><p>Source has an Input/Output System, it is a highly robust system for designing world logic. For example, all of Portal&rsquo;s puzzles are made using it. The main strength of it is that after making the basic components the designers can do everything else without much help from the programmers.
This is achieved with full integration with the Hammer world editor, and many smaller logical building blocks.</p><h3 id=io-system>I/O system<a hidden class=anchor aria-hidden=true href=#io-system>#</a></h3><p>The <a href=https://developer.valvesoftware.com/wiki/Inputs_and_Outputs>Valve developers wiki</a> gives a really good overview of how it works, but I will try to summarize it here as well.</p><p>Let&rsquo;s start with what is visible from the system to the user. Anything that can move or has any amount of data or logic is called an entity in Source. These are special as they can have more data on them. One of the most basic examples for an entity is a model, as these need the path of the model to draw, and the textures or shaders to use.</p><p>A more interesting example of entities are the non-visible ones, like spawners or particle emitters. These are not visible in the game, only in the editor.</p><p><img alt="Source engine entities" loading=lazy src=/posts/2022-02-26-game-io-logic/source_entities.jpg></p><p>All of these entities have an Input-Output tab in the editor</p><p>In the Source engine, you can set up connections between entities by connecting one of the entities&rsquo; outputs to another entity&rsquo;s input. These Outputs act as events and they are specific to the type of entity. For example a &ldquo;trigger region entity&rdquo; might have an output named <code>OnTrigger</code>, they also have Outputs inherited from their parent classes. Then these Outputs can be mapped to the Inputs on other entities. These Inputs are basically actions they can perform. For example, a fire particle entity might have <code>StartFire</code> and <code>Extinguish</code>.</p><p>These connections can be easily managed from the editor. The user can set up connections to define a delay to apply to the event, and also send optional parameters.</p><p><img alt="The broken screen" loading=lazy src=/posts/2022-02-26-game-io-logic/IO_menu.png></p><p>The interface has a Convenient dropdown to select the output and an object picker to select the targets.</p><p>The power of this system comes from the fact that there are many Logical entities. This allows the implementation of more complex logic.</p><h3 id=examples>Examples<a hidden class=anchor aria-hidden=true href=#examples>#</a></h3><p>Some examples of these integrations form Unity and Source:</p><ul><li><strong><a href=https://developer.valvesoftware.com/wiki/Game_text>game_text</a> entity</strong>
This is used for displaying text on the screen like a chapter title.</li><li><strong><a href=https://developer.valvesoftware.com/wiki/Game_score>game_score</a> entity</strong>
This entity can be used to add or subtract a point from a player.</li><li><strong><a href=https://developer.valvesoftware.com/wiki/Light_spot>light_spot</a> entity</strong>
This is a basic spotlight that has Inputs to turn it on ( <code>TurnOn</code> ) and off ( <code>TurnOff</code> ) and also to set a patterns to use for flickering the light.</li><li><strong><a href=https://developer.valvesoftware.com/wiki/Logic_auto>logic_auto</a> entity</strong>
This is an entity that can fire Outputs automatically when the game starts up.
For example, it has <code>OnMapSpawn</code>which is fired any time the map is loaded, there are also versions of this output for when the map is loaded from a save or as the start of a new game.</li><li><strong><a href=https://developer.valvesoftware.com/wiki/Logic_branch>logic_branch</a> entity</strong>
This entity holds a single bool value that can be toggled using its inputs (<code>Toggle</code> and <code>ToggleTest</code>) and it has outputs for when it is set to true and false (<code>OnTrue</code>, <code>OnFalse</code>)</li><li><strong><a href=https://developer.valvesoftware.com/wiki/Logic_compare>logic_compare</a> entity</strong>
This entity can compare two inputs and fire an Output based on the values received by it.</li><li><strong><a href=https://developer.valvesoftware.com/wiki/Logic_relay>logic_relay</a> entity</strong>
Using this entity it is possible to forward a single event to many other entities.</li><li><strong><a href=https://developer.valvesoftware.com/wiki/Npc_maker>npc_maker</a> entity</strong>
This entity is responsible for spawning NPCs, it has properties to specify the type, squad, and relations, they will have.
There are inputs to stop and start spawning or spawn a single one.</li></ul><h3 id=the-internals>The internals<a hidden class=anchor aria-hidden=true href=#the-internals>#</a></h3><p>Most of the code for this is found in the <a href=https://github.com/nillerusr/source-engine/blob/master/game/server/cbase.cpp#L251>cbase.cpp</a> file of the source code. After a bit of reading, we can see that it calls the <code>g_EventQueue.AddEvent</code> to actually send the event. This has a few parameters that, define the name of the Input to call, the name of the target as a string. It also takes in the rest of the things we can configure in the UI, the delay, the optional parameter.</p><p>After this, the <a href=https://github.com/ValveSoftware/source-sdk-2013/blob/master/sp/src/game/server/eventqueue.h>EventQueue</a> puts this into a list sorted by the time the event needs to fire (Current time + delay).
An interesting thing to note is that EventQueue does not fire the event in the same call. The events are actually acted upon at the top of the core game update loop. This is done in the <a href=https://github.com/nillerusr/source-engine/blob/master/game/server/cbase.cpp#L901>ServiceEvents</a> function.
This approach makes sure that long chains of events can&rsquo;t cause lag.</p><h2 id=unity>Unity<a hidden class=anchor aria-hidden=true href=#unity>#</a></h2><p>Unity has released an example project that shows how a more complex game might be put together in their engine. This project is a small adventure game with localized logic puzzles.</p><p>They made an event system that they talked about in the accompanying <a href="https://learn.unity.com/tutorial/3d-game-kit-reference-guide?uv=2020.3&amp;projectId=5c514897edbc2a001fd5bdd0#5c7f8528edbc2a002053b73e">Unity Learn</a> course. In their scripts they send commands rather than events, this is only a naming difference, they mean the same thing as events.
This event system is a simple one that only has a fixed number of event types ( <code>None, Activate, Deactivate, Open, Close, Spawn, Destroy, Start, Stop</code>). These are only to differentiate between the events sent to the same game object.</p><h3 id=components>Components<a hidden class=anchor aria-hidden=true href=#components>#</a></h3><h4 id=sending-commands>Sending commands<a hidden class=anchor aria-hidden=true href=#sending-commands>#</a></h4><p>Sending commands can be done by any script inheriting from <code>SendGameCommand</code>.
This has a <code>Send()</code> function that other scripts can use to send events. There are many, pre-made scripts, that inherit from <code>SendGameCommand</code>.
For example, <code>SendOnCollisionEnter</code>, <code>SendOnCollisionExit</code>, <code>SendOnCollisionStay</code> These send a command (event) on the respective collision event. There is also a full set of these for trigger events.
The target of the events is a script called: <code>Game Command Receiver</code>.</p><p><img loading=lazy src=/posts/2022-02-26-game-io-logic/Unity_GameKIT_Switch.png>
In the picture above, you can see these components in action. There is a simple box collider and when the player enters (layer filter set to <code>player</code>), it sends an <code>Activate</code> command to the GameObject <code>Crystal</code>.</p><h4 id=receiving-commands>Receiving commands<a hidden class=anchor aria-hidden=true href=#receiving-commands>#</a></h4><p>Any GameObject that needs to receive commands (events) needs the <code>Game Command Receiver</code> component. This acts as a hub for directing the event to the right Function inside the right component, this is done by having an internal list of which event to send to which component of the GameObject. These are registered by the component that wants to receive a given event.
Every script that wants to process commands is inherited from <code>GameCommandHandler</code> Witch registers itself in its <code>Awake</code> method.
It also gives fields for setting what event to listen to, setting a cooldown, and starting the timer.</p><p>There are many already made scripts that do inherit from <code>GameCommandHandler</code>.
These can do a variety of things like:</p><ul><li><code>PlaySound</code> that will play a sound when it gets a command</li><li><code>SetGameObjectActive</code> will activate and deactivate a set of target game objects.</li><li><code>SimpleTranslator</code> Is a script that can move an object from a start position to an end position with a lot of configurable options. This is for example used for the Big doors in the demo scene ( <code>DoorHuge</code> in scene <code>Level1</code> ).</li></ul><p><img loading=lazy src=/posts/2022-02-26-game-io-logic/Unity_GameKIT_Crystal.png></p><p>In the above image, we can see the other half of the previous example. This is the target of the switch from before. It has the Command receiver script that was targeted in the switch. The inspector of the receiver shows a list of scripts that send events to this, so it is easier to navigate backwards in the connections. There is also a material switcher component that is set to listen to <code>Activate</code> events, it is also set so that it only fires once. When it fires, it will switch out the material, so the gem will glow with blue.</p><p><img loading=lazy src=/posts/2022-02-26-game-io-logic/Unity_GameKIT_Crystal_2.png></p><p>With the gizmos turned back on we can see that the system has a deep editor integration as it shows the connected components with arrows leading to and from event sources.</p><p><img loading=lazy src=/posts/2022-02-26-game-io-logic/Unity_GameKIT_Counter.png></p><p>There is also a second GameObject targeted by the Switch, this is a counter. When it gets activated 3 times, it fires a second command that moves the door down.</p><h3 id=problems>Problems<a hidden class=anchor aria-hidden=true href=#problems>#</a></h3><p>The system doesn&rsquo;t allow a single component to target multiple objects, this results in the duplication of scripts on the same GameObjects. A good example of this is the switch above, where it has to trigger the graphical change on the Gem and the Counter increment.</p><p>The fact that there is a limited number of event types is also a means that expressing more complex or abstract actions becomes hard, and some commands might end up with non-intuitive names.</p><p>The system also calls the target immediately, this means that if there is a chain in the calls (for example what a rellay component would do) the game might lag for a single frame while all the calls are made.</p><h1 id=the-requirements>The requirements<a hidden class=anchor aria-hidden=true href=#the-requirements>#</a></h1><p>For designing a system that solves these logical connections, we need to decide what are the main requirements for it.
At first, these requirements should be high level, to see what are the most important aspects.</p><p>A world and gameplay logic system would need to be:</p><ol><li>Easy to use, eg. set up new connections</li><li>Generic</li><li>Fast</li></ol><h2 id=1-easy-to-use>1. Easy to use<a hidden class=anchor aria-hidden=true href=#1-easy-to-use>#</a></h2><p>The system needs to be easy to understand and use while developing the game. Any designer and non-programmer need to be able to add new connections to create the game world they envisioned.
This means that the system needs good editor tooling and integration to allow for seamless workflows.
We have seen this in both Unity and Source examples, they both have deep integration with the editor.</p><h2 id=2-generic>2. Generic<a hidden class=anchor aria-hidden=true href=#2-generic>#</a></h2><p>The system needs to be able to communicate with as many parts of the game and game engine, as possible. This means that the system should be able to interact with almost any part of the game. This for example includes the physics system, the cinematic choreography, inventory, and the quest system.</p><h2 id=3-fast>3. Fast<a hidden class=anchor aria-hidden=true href=#3-fast>#</a></h2><p>A system with this level of integration and usage needs to be fast. This can be achieved by using a similar system as what Valve is using. By only dispatching events at the top of the event loop, we can make sure, a longer event chain doesn&rsquo;t make the game stop. But the Valve system isn&rsquo;t perfect either. They do full name-based lookups which allows for wild card addressing and targeting multiple entities with the same name. But it can be costly.</p><h1 id=the-proposal-so-far>The proposal so-far<a hidden class=anchor aria-hidden=true href=#the-proposal-so-far>#</a></h1><p>This exploration of game world logic systems was made for a University project. Our group is making a larger open-world game, and the need for a way to interconnect our systems came up. The plan is to use a single unified system for interacting with the world and completing quests.</p><h2 id=entities>Entities<a hidden class=anchor aria-hidden=true href=#entities>#</a></h2><p>From these examples, we have decided that in our system we will keep the idea of a single Component that marks the GameObject as something that can send and/or receive events. This component will mark the GO as an entity, and make sure it has a unique id (Most likely a UUID)</p><p>These Entities would register themselves to a list of all loaded entities that would allow for fast ID-based lookup of them when sending events. These might have a grouping based on the sub-scene to allow for fast and comprehensive unloading.</p><h2 id=the-question-of-time-travel>The question of time travel<a hidden class=anchor aria-hidden=true href=#the-question-of-time-travel>#</a></h2><p>In our game, there is a chance that the target entity is not loaded, especially if the event is targeting multiple of the same type. The problem here is that if we just run the event when the entity gets loaded, then we might get undesired results. For example, when an explosion gets triggered, then that explosion will play out when that part of the map get&rsquo;s loaded next. This might only happen in-game days later.</p><p>To avoid this, we might need to introduce states or some other way to differentiate between events that got delayed because of the target not being loaded. A simple solution would be to have a companion function for all events that care about this difference. This secondary function would only get called when the event was delayed. This still means that each component is responsible for handling the difference.</p><h2 id=the-problem-of-cloning>The problem of cloning<a hidden class=anchor aria-hidden=true href=#the-problem-of-cloning>#</a></h2><p>There is also a second problem with only referring to entities with their UUID as this means that when a more complex entity is cloned, one that might have sub-entities, will have the same UUID as the one it was cloned from.</p><p>An example would be level designers using a prefab for a simple door. As they drag in the door, the UUID would stay the same and when firing a door open event, all the doors would open. Or when in-game a new enemy would spawn, it would also have conflicting internal IDs and no way to differentiate them from other enemies.</p><p>The solution to this problem is to make sure that when we clone any GameObject that is an entity, we regenerate the UUIDs</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://dpeter99.github.io/>dpeter99's blog
</a></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>