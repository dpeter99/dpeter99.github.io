<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Shadow engine ECS Part 1 | dpeter99's blog</title><meta name=keywords content><meta name=description content="Rethinking Entity-Component Systems: A Graph-Based Approach
When building a game engine from scratch, one of the most fundamental decisions you&rsquo;ll make is how to represent and manage your game world. The Entity-Component-System (ECS) pattern has become the gold standard for many modern engines, but after working with various implementations, I&rsquo;ve started to question whether the traditional approach is always the best fit for every game.
In this series, I&rsquo;ll be exploring a different take on ECS design—one that borrows concepts from graph theory to create a more flexible and intuitive system for game developers."><meta name=author content><link rel=canonical href=https://dpeter99.github.io/posts/2025-07-13-shdow-ecs-par-1/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://dpeter99.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://dpeter99.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://dpeter99.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://dpeter99.github.io/apple-touch-icon.png><link rel=mask-icon href=https://dpeter99.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://dpeter99.github.io/posts/2025-07-13-shdow-ecs-par-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://dpeter99.github.io/posts/2025-07-13-shdow-ecs-par-1/"><meta property="og:site_name" content="dpeter99's blog
"><meta property="og:title" content="Shadow engine ECS Part 1"><meta property="og:description" content="Rethinking Entity-Component Systems: A Graph-Based Approach When building a game engine from scratch, one of the most fundamental decisions you’ll make is how to represent and manage your game world. The Entity-Component-System (ECS) pattern has become the gold standard for many modern engines, but after working with various implementations, I’ve started to question whether the traditional approach is always the best fit for every game.
In this series, I’ll be exploring a different take on ECS design—one that borrows concepts from graph theory to create a more flexible and intuitive system for game developers."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-13T09:00:59+00:00"><meta property="article:modified_time" content="2025-07-13T09:00:59+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Shadow engine ECS Part 1"><meta name=twitter:description content="Rethinking Entity-Component Systems: A Graph-Based Approach
When building a game engine from scratch, one of the most fundamental decisions you&rsquo;ll make is how to represent and manage your game world. The Entity-Component-System (ECS) pattern has become the gold standard for many modern engines, but after working with various implementations, I&rsquo;ve started to question whether the traditional approach is always the best fit for every game.
In this series, I&rsquo;ll be exploring a different take on ECS design—one that borrows concepts from graph theory to create a more flexible and intuitive system for game developers."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://dpeter99.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Shadow engine ECS Part 1","item":"https://dpeter99.github.io/posts/2025-07-13-shdow-ecs-par-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Shadow engine ECS Part 1","name":"Shadow engine ECS Part 1","description":"Rethinking Entity-Component Systems: A Graph-Based Approach When building a game engine from scratch, one of the most fundamental decisions you\u0026rsquo;ll make is how to represent and manage your game world. The Entity-Component-System (ECS) pattern has become the gold standard for many modern engines, but after working with various implementations, I\u0026rsquo;ve started to question whether the traditional approach is always the best fit for every game.\nIn this series, I\u0026rsquo;ll be exploring a different take on ECS design—one that borrows concepts from graph theory to create a more flexible and intuitive system for game developers.\n","keywords":[],"articleBody":"Rethinking Entity-Component Systems: A Graph-Based Approach When building a game engine from scratch, one of the most fundamental decisions you’ll make is how to represent and manage your game world. The Entity-Component-System (ECS) pattern has become the gold standard for many modern engines, but after working with various implementations, I’ve started to question whether the traditional approach is always the best fit for every game.\nIn this series, I’ll be exploring a different take on ECS design—one that borrows concepts from graph theory to create a more flexible and intuitive system for game developers.\nThe Traditional Approach: Classes vs. Pure ECS Most game engines fall into one of two camps:\nThe Object-Oriented Approach (think early Unity, older engines): Every game object is a class—Player, Zombie, Spider, SuperBoss—all inheriting from a common Entity or GameObject base class. This approach is intuitive but becomes unwieldy as your game grows. You end up with deep inheritance hierarchies and tight coupling between data and behavior.\nThe Pure ECS Approach (modern Unity DOTS, Bevy, etc.): Entities are just IDs, Components are pure data, and Systems operate on collections of entities that have specific component combinations. This approach excels at performance and modularity but can feel disconnected when building complex, unique game objects.\nThe Problem with Pure ECS Pure ECS shines when dealing with uniform operations—rendering thousands of sprites, updating physics for hundreds of objects, or processing AI for dozens of enemies. The SQL-like query system makes these operations efficient and clean:\n// Pseudocode: Update all entities with Transform and Velocity for (auto\u0026 entity : query\u003cTransform, Velocity\u003e()) { entity.get\u003cTransform\u003e().position += entity.get\u003cVelocity\u003e().value * deltaTime; } But pure ECS starts to break down when you need to create unique, complex entities that appear only once in your game. Consider a boss fight with multiple phases, complex state management, and dozens of interconnected behaviors. In a pure ECS system, you often end up with:\nOne-off component-system pairs that only apply to a single entity Complex state machines spread across multiple systems Logic scattered across different files, making it hard to understand the complete behavior of a single entity This is why many Unity tutorials still separate MonoBehaviours (with their update methods) from pure ECS—the component-per-entity approach is simply more intuitive for complex, unique objects.\nLearning from Unreal Engine Unreal Engine’s Actor-Component system offers an interesting middle ground. Actors can contain components, but these components can also have their own hierarchical structure. For example:\nPlayer Actor ├── Skeleton Component │ ├── Torso │ └── Head │ └── Camera └── Inventory Component ├── Weapon Slot └── Consumable Slots This internal hierarchy is separate from the world hierarchy, where the same Player might have attached objects:\nWorld Hierarchy: ├── Player │ ├── Picked-up Weapon │ └── Temporary Power-up Effect Unreal distinguishes between “Children” (internal component structure) and “Attachments” (world relationships). This dual hierarchy system provides flexibility that pure ECS lacks.\nA Graph-Based Vision What if we could generalize this concept further? Instead of being limited to two types of relationships, what if we treated our entire game world as a graph where:\nNodes represent entities (both leaf and non-leaf) Edges represent relationships between entities Leaf nodes function like traditional components Non-leaf nodes can store their own data AND have child nodes In this system:\nNode = Entity (can store custom data) Leaf Node = Component (traditional component behavior) Edges = Relationships (parent-child, internal structure, attachments, etc.) This approach offers several advantages:\nFlexibility: You can create simple entities using just leaf components, or complex entities with custom data and internal structure Intuitive API: Developers can choose between traditional ECS queries and object-oriented instance methods Multiple Relationship Types: Beyond parent-child, you could have “ownership”, “attachment”, “dependency”, or any custom relationship your game needs Unified Mental Model: Everything is a node in a graph, making the system conceptually simpler What’s Coming Next In the next post, I’ll dive deeper into the API design—how developers would actually use this graph-based ECS system. We’ll explore:\nThe developer-facing API for creating and manipulating nodes How traditional ECS queries would work alongside instance methods Memory layout considerations for performance Real-world examples of complex entities built with this system The goal isn’t to replace pure ECS where it excels, but to provide a more flexible foundation that can adapt to different game development needs. Sometimes you need the raw performance of pure ECS, and sometimes you need the intuitive structure of object-oriented design. Why not have both?\nThis is part of a series on building a game engine from scratch. Follow along as we explore the challenges and solutions in modern game engine architecture.\n","wordCount":"764","inLanguage":"en","datePublished":"2025-07-13T09:00:59Z","dateModified":"2025-07-13T09:00:59Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://dpeter99.github.io/posts/2025-07-13-shdow-ecs-par-1/"},"publisher":{"@type":"Organization","name":"dpeter99's blog\n","logo":{"@type":"ImageObject","url":"https://dpeter99.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://dpeter99.github.io/ accesskey=h title="dpeter99's blog
 (Alt + H)">dpeter99's blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Shadow engine ECS Part 1</h1><div class=post-meta><span title='2025-07-13 09:00:59 +0000 UTC'>July 13, 2025</span></div></header><div class=post-content><h1 id=rethinking-entity-component-systems-a-graph-based-approach>Rethinking Entity-Component Systems: A Graph-Based Approach<a hidden class=anchor aria-hidden=true href=#rethinking-entity-component-systems-a-graph-based-approach>#</a></h1><p>When building a game engine from scratch, one of the most fundamental decisions you&rsquo;ll make is how to represent and manage your game world. The Entity-Component-System (ECS) pattern has become the gold standard for many modern engines, but after working with various implementations, I&rsquo;ve started to question whether the traditional approach is always the best fit for every game.</p><p>In this series, I&rsquo;ll be exploring a different take on ECS design—one that borrows concepts from graph theory to create a more flexible and intuitive system for game developers.</p><h2 id=the-traditional-approach-classes-vs-pure-ecs>The Traditional Approach: Classes vs. Pure ECS<a hidden class=anchor aria-hidden=true href=#the-traditional-approach-classes-vs-pure-ecs>#</a></h2><p>Most game engines fall into one of two camps:</p><p><strong>The Object-Oriented Approach</strong> (think early Unity, older engines):
Every game object is a class—Player, Zombie, Spider, SuperBoss—all inheriting from a common Entity or GameObject base class. This approach is intuitive but becomes unwieldy as your game grows. You end up with deep inheritance hierarchies and tight coupling between data and behavior.</p><p><strong>The Pure ECS Approach</strong> (modern Unity DOTS, Bevy, etc.):
Entities are just IDs, Components are pure data, and Systems operate on collections of entities that have specific component combinations. This approach excels at performance and modularity but can feel disconnected when building complex, unique game objects.</p><h2 id=the-problem-with-pure-ecs>The Problem with Pure ECS<a hidden class=anchor aria-hidden=true href=#the-problem-with-pure-ecs>#</a></h2><p>Pure ECS shines when dealing with uniform operations—rendering thousands of sprites, updating physics for hundreds of objects, or processing AI for dozens of enemies. The SQL-like query system makes these operations efficient and clean:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// Pseudocode: Update all entities with Transform and Velocity
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> entity : query<span style=color:#f92672>&lt;</span>Transform, Velocity<span style=color:#f92672>&gt;</span>()) {
</span></span><span style=display:flex><span>    entity.get<span style=color:#f92672>&lt;</span>Transform<span style=color:#f92672>&gt;</span>().position <span style=color:#f92672>+=</span> entity.get<span style=color:#f92672>&lt;</span>Velocity<span style=color:#f92672>&gt;</span>().value <span style=color:#f92672>*</span> deltaTime;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>But pure ECS starts to break down when you need to create unique, complex entities that appear only once in your game. Consider a boss fight with multiple phases, complex state management, and dozens of interconnected behaviors. In a pure ECS system, you often end up with:</p><ul><li>One-off component-system pairs that only apply to a single entity</li><li>Complex state machines spread across multiple systems</li><li>Logic scattered across different files, making it hard to understand the complete behavior of a single entity</li></ul><p>This is why many Unity tutorials still separate MonoBehaviours (with their update methods) from pure ECS—the component-per-entity approach is simply more intuitive for complex, unique objects.</p><h2 id=learning-from-unreal-engine>Learning from Unreal Engine<a hidden class=anchor aria-hidden=true href=#learning-from-unreal-engine>#</a></h2><p>Unreal Engine&rsquo;s Actor-Component system offers an interesting middle ground. Actors can contain components, but these components can also have their own hierarchical structure. For example:</p><pre tabindex=0><code>Player Actor
├── Skeleton Component
│   ├── Torso
│   └── Head
│       └── Camera
└── Inventory Component
    ├── Weapon Slot
    └── Consumable Slots
</code></pre><p>This internal hierarchy is separate from the world hierarchy, where the same Player might have attached objects:</p><pre tabindex=0><code>World Hierarchy:
├── Player
│   ├── Picked-up Weapon
│   └── Temporary Power-up Effect
</code></pre><p>Unreal distinguishes between &ldquo;Children&rdquo; (internal component structure) and &ldquo;Attachments&rdquo; (world relationships). This dual hierarchy system provides flexibility that pure ECS lacks.</p><h2 id=a-graph-based-vision>A Graph-Based Vision<a hidden class=anchor aria-hidden=true href=#a-graph-based-vision>#</a></h2><p>What if we could generalize this concept further? Instead of being limited to two types of relationships, what if we treated our entire game world as a graph where:</p><ul><li><strong>Nodes</strong> represent entities (both leaf and non-leaf)</li><li><strong>Edges</strong> represent relationships between entities</li><li><strong>Leaf nodes</strong> function like traditional components</li><li><strong>Non-leaf nodes</strong> can store their own data AND have child nodes</li></ul><p>In this system:</p><ul><li><strong>Node = Entity</strong> (can store custom data)</li><li><strong>Leaf Node = Component</strong> (traditional component behavior)</li><li><strong>Edges = Relationships</strong> (parent-child, internal structure, attachments, etc.)</li></ul><p>This approach offers several advantages:</p><ol><li><strong>Flexibility</strong>: You can create simple entities using just leaf components, or complex entities with custom data and internal structure</li><li><strong>Intuitive API</strong>: Developers can choose between traditional ECS queries and object-oriented instance methods</li><li><strong>Multiple Relationship Types</strong>: Beyond parent-child, you could have &ldquo;ownership&rdquo;, &ldquo;attachment&rdquo;, &ldquo;dependency&rdquo;, or any custom relationship your game needs</li><li><strong>Unified Mental Model</strong>: Everything is a node in a graph, making the system conceptually simpler</li></ol><h2 id=whats-coming-next>What&rsquo;s Coming Next<a hidden class=anchor aria-hidden=true href=#whats-coming-next>#</a></h2><p>In the next post, I&rsquo;ll dive deeper into the API design—how developers would actually use this graph-based ECS system. We&rsquo;ll explore:</p><ul><li>The developer-facing API for creating and manipulating nodes</li><li>How traditional ECS queries would work alongside instance methods</li><li>Memory layout considerations for performance</li><li>Real-world examples of complex entities built with this system</li></ul><p>The goal isn&rsquo;t to replace pure ECS where it excels, but to provide a more flexible foundation that can adapt to different game development needs. Sometimes you need the raw performance of pure ECS, and sometimes you need the intuitive structure of object-oriented design. Why not have both?</p><hr><p><em>This is part of a series on building a game engine from scratch. Follow along as we explore the challenges and solutions in modern game engine architecture.</em></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://dpeter99.github.io/>dpeter99's blog
</a></span>·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>